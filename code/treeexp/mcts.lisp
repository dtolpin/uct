(defpackage "MCTS"
  (:documentation "algorithms for Monte Carlo Tree Sampling")
  (:use "COMMON-LISP")
  (:export "*SAMPLING-FACTOR*" "WITH-UNIQUE-NODE-IDS"
           "SWITCH" "MAKE-SWITCH" "MAKE-ANTISWITCH" "SWITCH-NODES"
           "ARM" "MAKE-ARM" "ARM-MEAN"
           "MAKE-ARMF" "MAKE-ARMB" "MAKE-ARMV"
           "PULL-BEST-ARM"
           "MK-SAMPLING-SELECT"
           "COMPUTE-UQB-FACTOR"
           "*UQB-ALPHA*"))
(in-package "MCTS")

(defvar *debug* nil)

(defparameter *uqb-alpha* 8)

;;; Monte-Carlo Tree Sampling
;;; Common Notions

(defparameter *sampling-factor* 0
  "see function `number-of-samples'")

(defvar *node-id* 0
  "node identifier, internally used to uniquely
   identify nodes")

(defmacro with-unique-node-ids (&rest body)
  "evaluate `body' inside a new binding for *node-id*,
   so that all nodes generated by calls from `body' have
   distinct ids"
  `(let ((*node-id* 0))
     ,@body))

(defun shuffled-indices (sequence)
  "generate a shuffled list of indices"
  (let* ((i -1)
         (indices (map 'list (lambda (x) (declare (ignore x)) (cons (incf i) (random 1.0)))
                       sequence)))
    (mapcar #'car (sort indices #'> :key #'cdr))))

(defstruct node
  "search tree node, either a switch or an arm"
  (id (incf *node-id*) :read-only t))

(defstruct (switch (:include node))
  "a maximizing switch (internal) node"
  nodes) ; node vector

(defstruct (antiswitch (:include switch))
  "minimizing switch")

(defgeneric better-reward (switch reward best-reward)
  (:documentation "true iff reward better than best-reward")
  (:method ((switch switch) reward best-reward)
    (> reward best-reward))
  (:method ((switch antiswitch) reward best-reward)
    (< reward best-reward)))

(defgeneric lowest-reward (switch)
  (:documentation "the worst reward value")
  (:method ((switch switch)) most-negative-single-float)
  (:method ((switch antiswitch)) most-positive-single-float))

(defgeneric highest-reward (switch)
  (:documentation "the best reward value")
  (:method ((switch switch)) most-positive-single-float)
  (:method ((switch antiswitch)) most-negative-single-float))

(defgeneric upper-bound (switch reward bound)
  (:documentation "upper bound on reward")
  (:method ((switch switch) reward bound) (+ reward bound))
  (:method ((switch antiswitch) reward bound) (- reward bound)))

(defstruct (arm (:include node))
  "an arm"
  mean)

(defun number-of-samples (switch)
  "compute number of samples per node"
  (* (1+ *sampling-factor*) (length (switch-nodes switch))))


;; Handling sampling statistics

(defstruct stat
  "play stat"
  (count 0)
  (sum 0.0)
  (varsum 0.0)
  (rewards '()))

(defun stat-avg (stat)
  (/ (stat-sum stat)
     (max 1 (stat-count stat))))

(defun stat-avg* (stat)
  (if (plusp (stat-count stat)) (stat-avg stat) 0))

(defun square (x) (* x x))

(defun stat-var (stat)
  (/ (stat-varsum stat)
     (* (stat-count stat) (1- (stat-count stat)))))

(defun stat-key (switch node)
  "key of action in stats"
  (cons (node-id switch) (node-id node)))

(defvar *play-stats* nil
  "play stats used by adaptive sampling algorithms")

(defun get-stat (switch node)
  "get statistics for switch node pair, initializing
   to empty statistics if unsampled"
  (let ((key (stat-key switch node)))
    (or (gethash key *play-stats*)
        (setf (gethash key *play-stats*) (make-stat)))))

(defun update-stats (switch node reward)
  (let ((stat (get-stat switch node)))
    (incf (stat-count stat))
    (incf (stat-sum stat) reward)
    (dolist (r (stat-rewards stat))
      (incf (stat-varsum stat) (square (- reward r))))
    (push reward (stat-rewards stat)))
  reward)

;; Playing a playout

(defgeneric play (node select)
  (:documentation "play from this node, return reward"))

(defmethod play ((switch switch) select)
  "playing a switch --- selecting a direction"
  (multiple-value-bind (node select) (funcall select switch)
    (multiple-value-bind (reward mean) (play node select)
      (update-stats switch node reward)
      (values reward mean))))

(defmethod play ((arm arm) select)
  "playing a leaf node --- drawing the arm"
  (declare (ignore select))
  (values (draw arm) (arm-mean arm)))

;; Move selection function: sampling, then committing

(defun print-stats (stats)
  "print stats, for debugging"
  (when (member :print-stats *debug*)
    (progn (format t "~&~%")
           (map nil (lambda (stat) 
                        (format t "~@{~S~^ ~}~%"
                                (stat-count stat) (stat-avg* stat)))
                (sort (copy-seq stats) #'> :key #'stat-avg*)))))

(defgeneric mk-choose-best-child (alg)
  (:documentation "choose best child")
  (:method (alg)
    "choose best child by max reward"
    (lambda (switch stats)
      (print-stats stats)
      (let ((best-node nil)
            (best-avg (lowest-reward switch)))
        ;; select best action
        (dolist (i (shuffled-indices stats) best-node)
          (let ((avg (stat-avg (aref stats i))))
            (when (better-reward switch avg best-avg) 
              (setf best-node (aref (switch-nodes switch) i)
                    best-avg avg))))))))

(defgeneric mk-sampling-select (alg)
  (:documentation "make sampling select"))

(defun mk-commit-select (sampling-select choose-best-child)
  "sample actions, choose the one with the best average"
  (labels ((commit-select (switch)
             ;; gather playing statistics
             (dotimes (i (number-of-samples switch))
               (multiple-value-bind (node sampling-select)
                   (funcall sampling-select switch)
                 (when node ; sample if node is not nil, skip otherwise
                   (update-stats switch node (play node sampling-select)))))
             
             ;; extract statistics
             (values
              (funcall choose-best-child
                       switch
                       (map 'vector (lambda (node) (get-stat switch node))
                            (switch-nodes switch)))
              #'commit-select)))
    #'commit-select))

;; Various arms with different reward distributions can be defined
(defgeneric draw (arm)
  (:documentation "draw the arm and return the outcome"))

;; Finally, the main function --- pulling the best arm
(defun pull-best-arm (tree alg
                      &optional (*sampling-factor* *sampling-factor*))
  "pull the best arm"
  (let ((*play-stats* (make-hash-table :test #'equal)))
    (nth-value 1 (play tree (mk-commit-select (mk-sampling-select alg)
                                              (mk-choose-best-child alg))))))

;; Basic arm kinds
(defstruct (armf (:include arm))
  "fixed arm")
(defstruct (armb (:include arm))
   "Bernulli arm")

(defstruct (armv (:include arm))
  "Variance arm")

(defmethod draw ((arm armf))
  "fixed arm: always the mean"
  (arm-mean arm))

(defmethod draw ((arm armb))
  "Bernoulli arm: either 0.0 or 1.0"
  (if (< (random 1.0) (arm-mean arm)) 1.0 0.0))

(defmethod draw ((arm armv))
  "Fixed variance arm: either mean+delta or mean-delta"
  (if (< (random 1.0) 0.5)
      (+ (arm-mean arm) 0.5) (- (arm-mean arm) 0.5)))


;;; Sampling algorithms

;; Random sampling
(defun rnd (switch)
  "Uniform random sampling" 
  (let ((node-stats (map 'vector (lambda (node) (get-stat switch node))
                         (switch-nodes switch))))
    (dotimes (i (length node-stats))
      (when (zerop (stat-count (aref node-stats i)))
        (return-from rnd (aref (switch-nodes switch) i))))
    (aref (switch-nodes switch)
          (random (length (switch-nodes switch))))))


;; Single-level adaptive selection
(defun u*b (switch fun factor)
  "UCB selection: max (avg+sqrt(2*log (n) / ni))"
  (let* ((node-stats (map 'vector (lambda (node) (get-stat switch node))
                          (switch-nodes switch)))
         (root-2-log-n
          (sqrt (* factor (funcall fun (max 1 (reduce #'+ node-stats
                                                      :key #'stat-count
                                                      :initial-value 0))))))
         (best-node nil)
         (best-reward (lowest-reward switch)))

    (dolist (i (shuffled-indices (switch-nodes switch)) best-node)
      (when (zerop (stat-count (aref node-stats i)))
        (return (aref (switch-nodes switch) i)))
      (let ((reward (upper-bound switch (stat-avg (aref node-stats i))
                                 (/ root-2-log-n
                                    (sqrt (stat-count (aref node-stats i)))))))
        (when (better-reward switch reward best-reward)
          (setf best-node (aref (switch-nodes switch) i)
                best-reward reward))))))

(defun ucb (switch) (u*b switch #'log 2.0))

(defvar *uqb-factor* 1.0)

(defun compute-uqb-factor (k &optional (alpha *uqb-alpha*))
  "Computes *uqb-factor* such that 
    *uqb-factor* * sqrt(n)=2*log(n) for 
    n: 2*log(n)==n/2/k"
  (flet ((equ (n) (- (* alpha (log n)) (coerce (/ n k 2) 'double-float))))
    (let* ((xa k) (xb (floor most-positive-fixnum 2))
           (fa (equ xa)) (fb (equ xb))
           (n (loop
                 (when (< (abs (- fa fb)) 1e-3) (return xa))
                 (let* ((xc (* 0.5 (+ xa xb)))
                        (fc (equ xc)))
                   (if (= (signum fc) (signum fb))
                       (setf xb xc
                             fb fc)
                       (setf xa xc
                             fa fc))))))
      (setf *uqb-factor* (/ (* 2.0 (log n)) (sqrt n))))))

(defun uqb (switch) (u*b switch #'sqrt *uqb-factor*))

(defun grd (switch)
  "0.5-greedy selection"
  (let* ((node-stats (map 'vector (lambda (node) (get-stat switch node))
                          (switch-nodes switch)))
         (k (length (switch-nodes switch)))
         (best-node nil)
         (best-reward (lowest-reward switch)))

    (dolist (i (shuffled-indices (switch-nodes switch)) 
             (if (> (random 1.0) (* 0.5 (/ k (1- k))))
                 best-node
                 (aref (switch-nodes switch) (random k))))
      (when (zerop (stat-count (aref node-stats i)))
        (return-from grd (aref (switch-nodes switch) i)))
      (let ((reward (stat-avg (aref node-stats i))))
        (when (better-reward switch reward best-reward)
          (setf best-node (aref (switch-nodes switch) i)
                best-reward reward))))))

(defun v*b (switch voi)
  "UVB selection: max [(1-1/k)/ni for best-, 1/k/ni for rest]"
  (let* ((node-stats (map 'vector (lambda (node) (get-stat switch node))
                          (switch-nodes switch)))
         (alpha 0.0)
         (beta 0.0)
         (best-node nil)
         (best-reward most-negative-single-float))

    (dotimes (i (length node-stats))
      (when (zerop (stat-count (aref node-stats i)))
        (return-from v*b (aref (switch-nodes switch) i)))
      (let ((avg (stat-avg (aref node-stats i))))
        (cond
          ((> avg alpha)
           (psetf beta alpha
                  alpha avg))
          ((> alpha avg beta)
           (psetf beta avg)))))

    (dolist (i (shuffled-indices (switch-nodes switch)) best-node)
      (let ((reward (funcall voi alpha beta (aref node-stats i))))
        (when (>= reward best-reward)
          (setf best-node (aref (switch-nodes switch) i)
                best-reward reward))))))

(defun per-sample (voi n-samples)
  (/ voi (1+ n-samples)))

(defun voi-trivial (alpha beta stat)
  "Trivial VOI upper"
  (let ((avg (stat-avg stat)))
    (per-sample
     (if (> avg beta) beta (- 1.0 alpha))
     (stat-count stat))))

(flet ((estimate (n over under)
         (* over (exp (* -2.0 n (square under))))))

  (defun voi-hoeffding (alpha beta stat)
    "Chernoff-Hoeffding based VOI estimate"
    (per-sample
     (if (> (stat-avg stat) beta)
         (estimate (stat-count stat)
                   beta (- (stat-avg stat) beta))
         (estimate (stat-count stat)
                   ( - 1.0 alpha) (- alpha (stat-avg stat))))
     (stat-count stat))))

(flet ((estimate (n over under)
         (* over (exp (* -2.0 n (square under))))))

  (defun voi-thoeffding (alpha beta stat)
    "Minimum of trivial and Chernoff-Hoeffding based perfect VOI estimate"
    (min 
     (voi-trivial alpha beta stat)
     (if (> (stat-avg stat) beta)
         (estimate (stat-count stat)
                   beta (- (stat-avg stat) beta))
         (estimate (stat-count stat)
                   ( - 1.0 alpha) (- alpha (stat-avg stat)))))))

(flet ((estimate (n over under)
         (if (zerop over) most-negative-single-float (+ (log over) (* -2.0 n (square under)))))
       (per-sample (voi n-samples)
         (- voi (log n-samples))))

  (defun voi-loeffding (alpha beta stat)
    "Chernoff-Hoeffding based VOI estimate, logariphmic"
    (per-sample
     (if (> (stat-avg stat) beta)
         (estimate (stat-count stat)
                   beta (- (stat-avg stat) beta))
         (estimate (stat-count stat)
                   ( - 1.0 alpha) (- alpha (stat-avg stat))))
     (stat-count stat))))

(let ((a1 0.254829592d0)
      (a2 -0.284496736d0)
      (a3 1.421413741d0)
      (a4 -1.453152027d0)
      (a5 1.061405429d0)
      (p 0.3275911d0))

  (defun erf (x)    
    "ERF, the error function, approximation according to A&S 7.1.26"
    (let* ((y (/ 1.0 (+ 1.0 (* p (abs x)))))
           (z (- 1.0 (* y (exp (- (* x x))) 
                        (+ a1 (* y (+ a2 (* y (+ a3 (* y (+ a4 (* y a5))))))))))))
      (declare (type double-float y z))
      (if (plusp x) z (- z)))))


(let ((c (sqrt 2.0)))
  (flet ((estimate (n over under)
           (let ((sqrt-n (sqrt n)))
             (/ (- (erf (* c sqrt-n over)) (erf (* c sqrt-n under))) (* n sqrt-n)))))
    
    (defun voi-ihoe (alpha beta stat)
      "Chernoff-Hoeffding based VOI estimate, integral"
      (let ((avg (stat-avg stat))
            (n (1+ (stat-count stat))))
        (if (> (stat-avg stat) beta)
            (estimate n alpha (- alpha beta))
            (estimate n ( - 1.0 avg) (- alpha avg)))))))
  
;; find root of a function by bisection
(labels ((bs (f a b fa fb eps)
           (declare (optimize (speed 3) (debug 0)))
           (let* ((c (* 0.5 (+ a b)))
                  (fc (funcall f c)))
             (cond
               ((eql (>= fa 0.0) (>= fb 0.0)) a)
               ((<= (- b a) eps) c)
               ((eql (>= fb 0) (>= fc 0)) (bs f a c fa fc eps))
               (t (bs f c b fc fb eps))))))

  (defun bisection (f a b eps)
    "finds root of f in interval a b"
    (bs f a b (funcall f a) (funcall f b) eps)))

;; computing erf, the error function
(let ((a1 0.254829592d0)
      (a2 -0.284496736d0)
      (a3 1.421413741d0)
      (a4 -1.453152027d0)
      (a5 1.061405429d0)
      (p 0.3275911d0))

  (defun erf (x)    
    "ERF, the error function, approximation according to A&S 7.1.26"
    (let* ((y (/ 1.0d0 (+ 1.0d0 (* p (abs x)))))
           (z (- 1.0d0
                 (* y (exp (- (* x x))) 
                    (+ a1 (* y (+ a2 (* y (+ a3 (* y (+ a4 (* y a5))))))))))))
      (if (plusp x) z (- z)))))

;; Hoeffding with Eyal's correction
(flet ((estimate (n over under)
         (flet ((destim (between)
                  (- (* 4.0 n over between (exp (* -2.0 n (square between))))
                     (exp (* -2.0 n (square under))))))

           (let ((between (bisection #'destim under (+ under over) 0.001)))
             (+ (* (- between under) (exp (* -2.0 n (square under))))
                (* over (exp (* -2.0 n (square between)))))))))
 
  (defun voi-eyal (alpha beta stat)
    "Improved by mid-point Chernoff-Hoeffding estimate"
    (per-sample
     (if (> (stat-avg stat) beta)
         (estimate (stat-count stat)
                   beta (- (stat-avg stat) beta))
         (estimate (stat-count stat)
                   ( - 1.0 alpha) (- alpha (stat-avg stat))))
     (stat-count stat))))

(flet ((estimate (n over under var)
         (* 2 over (exp (- (/ (* n (square under))
                              (+ (/ (* 14.0 n under)
                                    (* 3.0 (1- n))) 
                                 (* 2 var)
            #| avoid 0/0 |#      least-positive-short-float)))))))

  (defun voi-bernstein (alpha beta stat)
    "Empirical Bernstein based VOI estimate"
    (cond
      ((= (stat-count stat) 1) (voi-hoeffding alpha beta stat))
      (t (min (voi-hoeffding alpha beta stat)
              (per-sample
               (if (> (stat-avg stat) beta)
                   (estimate (stat-count stat)
                             beta (- (stat-avg stat) beta)
                             (stat-var stat))
                   (estimate (stat-count stat)
                             (- 1.0 alpha) (- alpha (stat-avg stat)) 
                             (stat-var stat)))
               (stat-count stat)))))))
                 
(defun vtb (switch) (v*b switch #'voi-trivial))
(defun vhb (switch) (v*b switch #'voi-hoeffding))
(defun vib (switch) (v*b switch #'voi-ihoe))
(defun vthb (switch) (v*b switch #'voi-thoeffding))
(defun vlb (switch) (v*b switch #'voi-loeffding))
(defun veb (switch) (v*b switch #'voi-eyal))
(defun vbb (switch) (v*b switch #'voi-bernstein))

;;; Adaptive sampling selection functions for passing to `pull-best-arm'

(defmacro def-mk-sampling-select (alg first next-alg)
  `(defmethod mk-sampling-select ((alg (eql ,alg)))
     (lambda (switch)
       (values (,first switch) (mk-sampling-select ,next-alg)))))

;; Random
(def-mk-sampling-select :rnd rnd :rnd)

;; Random than UCT
(def-mk-sampling-select :rct rnd :uct)

;; UCT
(def-mk-sampling-select :uct ucb :uct)
(def-mk-sampling-select :uctc ucb :uct)

(defmethod mk-choose-best-child ((alg (eql :uctc)))
  "choose best child by max count"
  (lambda (switch stats)
    (print-stats stats)
    (let ((best-node nil)
          (max-count 0))
      ;; select best action
      (dolist (i (shuffled-indices stats) best-node)
        (let ((count (stat-count (aref stats i))))
          (when (> count max-count)
            (setf best-node (aref (switch-nodes switch) i)
                  max-count count)))))))

;; GCT 
(def-mk-sampling-select :gct grd :uct)

;; QCT
(def-mk-sampling-select :qct uqb :uct)

;; TCT (Trivial then UCT)
(def-mk-sampling-select :tct vtb :uct)

;; HCT (Hoeffding then UCT)
(def-mk-sampling-select :hct vhb :uct)

;; ICT (Integrated Hoeffding then UCT)
(def-mk-sampling-select :ict vib :uct)

;; THCT (Thoeffding then UCT)
(def-mk-sampling-select :thct vthb :uct)

;; LCT (Logarithmic Hoeffding then UCT)
(def-mk-sampling-select :lct vlb :uct)

;; ECT (hoEffding then UCT)
(def-mk-sampling-select :ect veb :uct)

;; BCT (Bernstein then UCT)
(def-mk-sampling-select :bct vbb :uct)

;; Testing

(defmacro RUN-TEST (test-name)
  `(progn 
     (format *error-output* " ~(~A~)" ',test-name)
     (clear-output *error-output*)
     (,test-name)
     (format *error-output* " (ok)")
     (clear-output *error-output*)))

(let ((test-tree (make-switch :nodes (vector (make-armf :mean 0.0) (make-armf :mean 1.0))))
      (*sampling-factor* 1))

  (defun test-uct ()
    (assert (= (pull-best-arm test-tree :uct) 1.0))))

(defun test ()
  (format *error-output* "Testing ~A:" (package-name (symbol-package 'test)))
  (run-test test-uct)
  (format *error-output* "~%") (clear-output *error-output*))


(eval-when (:execute :load-toplevel)
  (test))
